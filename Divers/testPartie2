#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <errno.h>
#include <fcntl.h>
#include <linux/limits.h>
#include <unistd.h>
#include <string.h>

int main(int argc, char *argv[])
{
    pid_t pid, childpid;
    int pipeToParent[2], fd, waitStatus;
    char dataBuffer[2000] = "", pipeBuffer[2000] = "buffer", *token, delimiter[2] = "\n";

    if((fd = open("data.txt", O_RDONLY)) < 0) // file opening
    {
        perror("open error ");
        exit(errno);
    }

    if((read(fd, dataBuffer, 2000)) < 0) // file reading
    {
        perror("read error ");
        exit(errno);
    }

    if((close(fd)) < 0)
    {
        perror("close open error ");
        exit(errno);
    }

    if((pipe(pipeToParent)) < 0) // pipe creation
    {
        perror("pipe to parent error ");
        exit(errno);
    }

    token = strtok(dataBuffer, delimiter); // strtok starting
    while (token != NULL) // while strtok returns NULL
    {

        if((pid = fork()) < 0) // fork creation
        {
            perror("fork error ");
            exit(errno);
        }

        printf("after fork\n");

        if(pid)
        {
            // parent
            printf("before wait\n");

            if((wait(NULL)) < 0) // wait until child dead
            {
                perror("wait error ");
                exit(errno);
            }
            printf("after wait\n");

            // sleep(3);

            printf("before read\n");

            printf("buffer : %s\n", pipeBuffer);

            if((read(pipeToParent[0], pipeBuffer, 2000)) < 0)
            {
                perror("parent read error ");
                exit(errno);
            }

            printf("after read\n");

            printf("Results parent : %s\n", pipeBuffer);

            memset(pipeBuffer, 0, 2000);
        }

        else
        {
            // child

            if((close(pipeToParent[0])) < 0)
            {
                perror("child close pipe reading error ");
                exit(errno);
            }

            if ((dup2(pipeToParent[1], 2)) < 0)
            {
                perror("child dup stdout error ");
                exit(errno);
            }
            if ((dup2(pipeToParent[1], 3)) < 0)
            {
                perror("child dup stderr error ");
                exit(errno);
            }
            
            if((close(pipeToParent[1])) < 0)
            {
                perror("child close pipe writing error ");
                exit(errno);
            }

            // char **commandLine = malloc((strlen(token) + 1) * sizeof(char *));
        
            // if (strlen(token) > 1)
            // {
            //     commandLine[0] = argv[1];
            //     for (int i = 0; i < strlen(token); ++i)
            //     {
            //         commandLine[i+1] = argv[i+2];
            //     }
            //     commandLine[strlen(token)]=NULL;
            // }

            // if(!(execvp(commandLine[0], commandLine)))
            // {
            //     perror("Execlp child error ");
            //     exit(errno);
            // }

            printf("end of child\n");
            exit(0);
        }
        token = strtok(NULL, delimiter);        
    }

    if((close(pipeToParent[1])) < 0) // parent close pipe writing
    {
        perror("close pipe writing error ");
        exit(errno);
    }

    if((close(pipeToParent[0])) < 0)
    {
        perror("close pipe reading error ");
        exit(errno);
    }

    printf("closed \n");
    exit(0); // sucess
}
